Gestion du cycle de vie

asyncio.run(coro) â†’ lance une coroutine principale et gÃ¨re la boucle dâ€™Ã©vÃ©nements.

asyncio.create_task(coro) â†’ programme une coroutine pour sâ€™exÃ©cuter en arriÃ¨reâ€‘plan.

Attente et dÃ©lais

asyncio.sleep(secs) â†’ suspend une coroutine sans bloquer la boucle.

asyncio.wait_for(coro, timeout) â†’ attend une coroutine avec dÃ©lai maximum.

asyncio.timeout(secs) â†’ contexte pour limiter la durÃ©e dâ€™une opÃ©ration.

Synchronisation

asyncio.gather(*coros) â†’ exÃ©cute plusieurs coroutines en parallÃ¨le et rÃ©cupÃ¨re toutes les rÃ©ponses.

asyncio.wait(tasks) â†’ attend que certaines ou toutes les tÃ¢ches soient terminÃ©es.

asyncio.shield(coro) â†’ protÃ¨ge une coroutine contre lâ€™annulation.

Communication entre tÃ¢ches

asyncio.Queue() â†’ file dâ€™attente asynchrone pour Ã©changer des donnÃ©es entre coroutines.

asyncio.Event() â†’ signal pour synchroniser plusieurs coroutines.

asyncio.Lock() â†’ verrou pour Ã©viter les accÃ¨s concurrents Ã  une ressource.

RÃ©seau et I/O

asyncio.open_connection(host, port) â†’ ouvre une connexion TCP asynchrone.

asyncio.start_server(handler, host, port) â†’ lance un serveur TCP asynchrone.

asyncio.StreamReader / StreamWriter â†’ lecture/Ã©criture asynchrone sur des flux.

âœ… Exemple pratique
ExÃ©cuter deux tÃ¢ches en parallÃ¨le :

python
import asyncio

async def task1():
    await asyncio.sleep(2)
    return "RÃ©sultat 1"

async def task2():
    await asyncio.sleep(3)
    return "RÃ©sultat 2"

async def main():
    results = await asyncio.gather(task1(), task2())
    print(results)

asyncio.run(main())
ğŸ‘‰ Ici, les deux tÃ¢ches sâ€™exÃ©cutent en mÃªme temps. RÃ©sultat affichÃ© aprÃ¨s 3 secondes :

Code
['RÃ©sultat 1', 'RÃ©sultat 2']
En rÃ©sumÃ©, asyncio est un outil de coordinationâ€¯: il permet de lancer plusieurs opÃ©rations en parallÃ¨le, de gÃ©rer les dÃ©lais, et de synchroniser les coroutines sans bloquer ton programme.

âš¡ Veuxâ€‘tu que je te prÃ©pare un miniâ€‘exemple oÃ¹ un WebSocket FastAPI utilise asyncio.gather() pour envoyer des messages rÃ©guliers tout en Ã©coutant les messages du client en parallÃ¨leâ€¯?

et c'est quoi le coroutines ?
Une coroutine en Python est une fonction spÃ©ciale qui peut Ãªtre suspendue et reprendre plus tard, ce qui permet dâ€™exÃ©cuter plusieurs tÃ¢ches de faÃ§on asynchrone sans bloquer le programme.

ğŸ” CaractÃ©ristiques dâ€™une coroutine
DÃ©finie avec async def au lieu de def.

Elle ne sâ€™exÃ©cute pas directementâ€¯: elle retourne un objet coroutine.

Pour lâ€™exÃ©cuter, il faut utiliser await ou la lancer dans la boucle dâ€™Ã©vÃ©nements (asyncio.run, asyncio.create_task).

Elle peut Ãªtre mise en pause avec await (par exemple await asyncio.sleep(10)), ce qui laisse la boucle dâ€™Ã©vÃ©nements continuer dâ€™autres tÃ¢ches.